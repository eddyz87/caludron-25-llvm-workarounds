\batchmode
\PassOptionsToPackage{prologue,dvipsnames}{xcolor}
% don't show red boxes around lexing errors
\AtBeginEnvironment{minted}{\renewcommand{\fcolorbox}[4][]{#4}}
\documentclass{beamer}
\setbeamersize{text margin left=15pt,text margin right=15pt} 
\setbeamertemplate{frametitle continuation}{\usebeamerfont{frametitle}\small{(\insertcontinuationcount)}}

%%\usepackage[dvipsnames]{xcolor}

\usepackage{minted}
\setminted{escapeinside=!!}
\setminted{fontsize=\small}
%%\setminted{ignorelexererrors=true}

\usepackage{parskip}
\setlength{\parskip}{\medskipamount} 

%%\usepackage{noto}
\usepackage[scaled]{beramono}
\usepackage[T1]{fontenc}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\marker}[2]{\colorbox{#1}{#2}}
\newcommand{\green }[1]{\marker{SpringGreen!40}{#1}}
\newcommand{\yellow}[1]{\marker{Goldenrod!40}{#1}}
\newcommand{\blue  }[1]{\marker{SkyBlue!40}{#1}}

\title{LLVM BPF backend optimizer workarounds}
\date{}

\begin{document}

\frame{\titlepage}

\begin{frame}[fragile]
\frametitle{Preface}

\begin{itemize}
\item Optimizing compiler transforms the structure of the input C code.
\item Sometimes, such transformations obscure the Linux kernel BPF
  verifier's ability to reason about the program.
\item LLVM BPF backend has accumulated a number of transformations
  aimed at preventing certain optimizations from being applied.
\item This presentation enumerates these backend transformations.
\item The goal of this presentation is to discuss how GCC BPF backend
  addresses, or plans to address, the same issues.
\item Another goal is to revive the discussion about
  \code{-Overifyable} compiler option.
\end{itemize}

%% Over the years, LLVM BPF backend accumulated a number of
%% transformations aimed at preserving the structure of the input C code
%% from optimizer rewrites, where those rewrites conflict with kernel BPF
%% verifier understanding the code.

%% I'll give a short overview of the BPF verifier itself, and describe
%% the patterns each such transformation tries to preserve.

\end{frame}

\begin{frame}[allowframebreaks,fragile]
  \frametitle{Kernel BPF verifier}

  At it's core Linux Kernel BPF verifier is a path-tracing machine.
  \begin{columns}[t]
    \column{0.45\textwidth}
    \scriptsize
    \begin{itemize}
    \item It simulates instructions execution one-by-one.
    \item Forks the state at branching points.
    \item Tracks register and stack state.
    \end{itemize}
    \column{0.65\textwidth}
    \begin{minted}[highlightlines={2,10,13,22},fontsize=\tiny]{c}
Live regs before insn:
    0: .......... (85) call bpf_get_prandom_u32
    1: 0......... (bf) r1 = r0
    2: 01........ (07) r1 += 5
.-- 3: 01........ (35) if r0 >= 0x5 goto pc+5
|   4: .1........ (18) r0 = 0xffffc90000188000
|   6: 01........ (0f) r0 += r1
|   7: 0......... (71) r0 = *(u8 *)(r0 +0)
|   8: 0......... (95) exit
'-> 9: .......... (b7) r0 = 42
   10: 0......... (95) exit

0: (85) call bpf_get_prandom_u32 ; !\scalebox{.9}[1.0]{R0=scalar()}!
1: (bf) r1 = r0                  ; !\scalebox{.9}[1.0]{R0=scalar(id=1) R1=scalar(id=1)}!
2: (07) r1 += 5                  ; !\scalebox{.9}[1.0]{R1=scalar(id=1+5)}!
3: (35) if r0 >= 0x5 goto pc+5   ; !\scalebox{.9}[1.0]{R0=scalar(id=1,umin=0,umax=4)}!
4: (18) r0 = 0xffffc90000188000  ; !\scalebox{.9}[1.0]{R0=map\_value()}!
6: (0f) r0 += r1                 ; !\scalebox{.9}[1.0]{R0=map\_value(umin=5,umax=9)}!
7: (71) r0 = *(u8 *)(r0 +0)      ; !\scalebox{.9}[1.0]{R0=scalar(umin=0,umax=255)}!
8: (95) exit

from 3 to 9: !\scalebox{.9}[1.0]{R0=scalar(id=1,umin=5) R1=scalar(id=1) R10=fp0}!
9: (b7) r0 = 42                  ; !\scalebox{.9}[1.0]{R0=42}!
10: (95) exit      
    \end{minted}
  \end{columns}

  \framebreak

    \scriptsize
    \begin{itemize}
    \item The interval and known bits abstract domains are used to
      represent values.
    \item Linear relations of the form $r_u + a = r_v + b$ are tracked
      for 64-bit registers and stack slots.
    \item Only addition and jump instructions preserve these relations.
    \end{itemize}

    \begin{minted}[fontsize=\tiny,highlightlines={2,3,4,6}]{c}
0: (85) call bpf_get_prandom_u32    ; R0=scalar()
1: (bf) r1 = r0                     ; R0=scalar(id=1) R1=scalar(id=1)
2: (07) r1 += 5                     ; R1=scalar(id=1+5)
3: (35) if r0 >= 0x5 goto pc+5      ; R0=scalar(id=1,umin=0,umax=4)
4: (18) r0 = 0xffffc90000188000     ; R0=map_value()
6: (0f) r0 += r1                    ; R0=map_value(umin=5,umax=9)
7: (71) r0 = *(u8 *)(r0 +0)         ; R0=scalar(umin=0,umax=255)
8: (95) exit

from 3 to 9: R0=scalar(id=1,umin=5) R1=scalar(id=1) R10=fp0
9: R0=scalar(id=1,umin=5) R1=scalar(id=1) R10=fp0
9: (b7) r0 = 42                     ; R0=42
10: (95) exit      
    \end{minted}

\end{frame}

\begin{frame}
  \frametitle{The list of backend transformations}

  The next few slides showcase patterns that the BPF backend attempts
  to block the LLVM optimizer from matching.

  \begin{itemize}
    \item Address calculation hoisting
    \item \code{x < a || x > b} rewrite
    \item \code{if (x <= $2^n$) ...} rewrite
    \item \code{\_\_attribute\_\_((preserve\_static\_offset))}
  \end{itemize}
\end{frame}

\begin{frame}[allowframebreaks,fragile]
  \frametitle{Address calculation hoisting}

  From C point of view the two programs below are identical:
  \vspace{1cm}

  \begin{columns}
    \column{0.35\textwidth}
    \begin{minipage}{\textwidth}
      \begin{minted}{C}
off = ...
if (off < 42) {
  ptr = packet + off;
  ... *ptr ...
}
      \end{minted}
    \end{minipage}
    \column{0.1\textwidth}
    $\rightarrow$
    \column{0.5\textwidth}
    \begin{minipage}{\textwidth}
      \begin{minted}{C}
off = ...
ptr = packet + off;
if (off < 42) {
  ... *ptr ...
}
      \end{minted}
    \end{minipage}
  \end{columns}

  \framebreak

  The verifier does not track relations between scalars and pointers,
  so it cannot propagate range information backward from \code{off} to
  \code{ptr}.

  \begin{minted}{C}
  off = ...
  ptr = packet + off;
  if (off < 42) {
    ... *ptr ... /* !\textcolor{red}{verification error here}! */
  }
  \end{minted}

  \framebreak

LLVM BPF backend attempts to block such code motion by inserting
special intrinsic calls\footnote{\tiny{Handled by \code{BPFAdjustOptImpl::avoidSpeculation()}.}}:

  \begin{minted}{C}
  !\blue{off}! = ...
  if (!\yellow{off < 42}!) {
    off = !\textcolor{Red}{@llvm.bpf.passthrough.i32.i32}!(<uid>, i32 off);
    ptr = packet !\green{+ off}!;
    ... *ptr ...
  }
  \end{minted}

By matching value \blue{definition}, \yellow{icmp} and \green{address calculation} pattern.

\end{frame}

\begin{frame}[allowframebreaks,fragile]
  \frametitle{\code{x < a || x > b}}

  LLVM's \code{InstCombine} pass consists of a large set of peephole
  rewrite patterns. One these patterns looks as follows:

  \vspace{1cm}

  \begin{columns}
    \hspace{.5cm}
    \column{0.3\textwidth}
    \begin{minipage}{\textwidth}
      \begin{minted}{C}
if (v < 1)
        return 0;
if (v > 7)
        return 0;
return arr[v];
      \end{minted}
    \end{minipage}
    \column{0.1\textwidth}
    $\rightarrow$
    \column{0.45\textwidth}
    \begin{minipage}{\textwidth}
      \begin{minted}{C}
t = v;
t -= 8;
if ((u32)t < (u32)-7)
	return 0;
return arr[v];
      \end{minted}
    \end{minipage}
  \end{columns}

  \framebreak

  This is a problem for verifier:

  \begin{minted}[fontsize=\fontsize{7}{8},frame=lines,framesep=5mm,highlightlines=5]{c}
  ...  w1 = v, w2 = t ...
; t = v;
  3: (bc) w2 = w1                       ; R1=R2=scalar(id=1,umin=0,umax=0xffffffff)
; t -= 8;
  4: (04) w2 += -8                      ; R2=scalar(umin=0,umax=0xffffffff...)
  5: (a6) if w2 < 0xfffffff9 goto pc+5  ; R2=scalar(...smin32=-7,smax32=-1...)
  6: (bc) w1 = w1                       ; R1=scalar(id=1,umin=0,umax=0xffffffff...)
  7: (18) r2 = <arr> ll                 ; R2=map_value(...)
  9: (0f) r2 += r1
  10: (71) r0 = *(u8 *)(r2 +0)
  R2 unbounded memory access, make sure to bounds check any such access
  \end{minted}

    %%\vspace{0.5cm}

  At (4) verifier drops relationship between \code{r1} and \code{r2},
  as it does not preserve linear relations after 32-bit operations.

  \framebreak

The workaround is to hide from the optimizer the fact that both
conditionals operate on the same value.

Match a sequence of basic blocks:

\begin{minted}[fontsize=\small]{llvm}
entry:
  %cmp = icmp ult i64 !\green{%x}!, 1
  br i1 %cmp, label %if.then, label !\yellow{%if.end}!

!\yellow{if.end}!:
  %cmp1 = icmp ugt i64 !\green{%x}!, 7
  br i1 %cmp1, label %if.then2, label %if.end3
\end{minted}

  \framebreak

  And break the pattern by obfuscating \code{\%x} for the first
  \code{icmp} \footnote{\tiny{\parbox{\textwidth}{
        \code{Handled by BPFAdjustOptImpl::serializeICMPCrossBB()} and\\
        \code{BPFAdjustOptImpl::serializeICMPInBB()}. }}}:

  \vspace{0.5cm}

\begin{minted}[fontsize=\small,highlightlines=3]{llvm}
entry:
  %cmp = icmp ult i64 %x, 1
  %2 = call i1 @llvm.bpf.passthrough.i1.i1(i32 2, i1 %cmp)
  br i1 %2, label %if.then, label %if.end

if.end:
  %cmp1 = icmp ugt i64 %x, 7
  br i1 %cmp1, label %if.then2, label %if.end3
\end{minted}
    
\end{frame}

\begin{frame}[allowframebreaks,fragile]
  \frametitle{\code{if (x <= $2^n$) ...}}

Same \code{InstCombine} pass applies the following transformation:

  \vspace{1cm}

  \begin{columns}
    \hspace{0.5cm}
    \column{0.45\textwidth}
    \begin{minipage}{\textwidth}
      \begin{minted}{C}
int foo(long x) {
  if ((unsigned)x <= !$2^n$!)
    return arr[x];
  return 0;
}
      \end{minted}
    \end{minipage}
    \column{0.1\textwidth}
    $\rightarrow$
    \column{0.45\textwidth}
    \begin{minipage}{\textwidth}
      \begin{minted}{C}
int foo(long x) {
  if (x & (!$2^{32} - 2^n$!))
    return arr[x];
  return 0;
}
      \end{minted}
    \end{minipage}
  \end{columns}

  \framebreak
  
  This is a problem for verifier:

  \begin{minted}[fontsize=\fontsize{7}{8},frame=lines,framesep=5mm,highlightlines={4,5}]{c}
 6: (18) r2 = 0xfffffffe              ; R2=0xfffffffe
; if ((unsigned)x <= 1) {
 8: (bf) r3 = r1                      ; R1=scalar(id=1) R3=scalar(id=1)
 9: (5f) r3 &= r2                     ; R3=scalar(...umin=0,umax=0xfffffffe...)
10: (55) if r3 != 0x0 goto pc+6       ; R3=0
; return arr[x];
11: (18) r2 = <arr> ll                ; R2=map_value(...)
13: (0f) r2 += r1
math between map_value pointer and register with unbounded min value is not allowed
  \end{minted}

At (9), \code{r3 \&= r2} breaks the relation between \code{r3} and \code{r2}.\\
At (10), no range for \code{r1} can be inferred from the \code{r3 == 0} branch entry.

  \framebreak

  The workaround is two hide comparison from optimizer, by mathcing
  this specifi pattern:

\begin{minted}[fontsize=\small]{llvm}
  %cmp = icmp ule i32 %conv, !$2^n$!
  br i1 %cmp, label %if.then, label %if.end
\end{minted}

And replace it with the a call to a backend specific intrinsic:

\begin{minted}[fontsize=\small]{llvm}
  %0 = call i1 @llvm.bpf.compare.i32.i32
                 (i32 37, i32 %conv, i32 !$2^n$!)
  br i1 %0, label %if.then, label %if.end
\end{minted}
  
\end{frame}

\begin{frame}[allowframebreaks,fragile]
  \frametitle{\large\code{\_\_attribute\_\_((preserve\_static\_offset))}}

  Verifier has a concept of ``context'' types, which:
  \begin{itemize}
  \item describe the input parameters of BPF programs;
  \item provide a C-level representation for BPF programs that differs
    from physical layout of kernel data structures.
  \end{itemize}

  As part of the verification process, load and store instructions
  operating on these types are patched to use the correct physical
  layout, e.g.:

  \begin{minted}[fontsize=\footnotesize]{c}
  int foo(struct bpf_sockopt *ctx) {
	... ctx->retval ...      
  }
  \end{minted}

  Is translated as \code{r$_x$ = *(u32 *)(r1 \textcolor{Red}{+ 36})} and is
  patched to an equivalent of:

  \begin{minted}[fontsize=\footnotesize]{c}
  (struct sockopt_kern *)r1->current_task->bpf_ctx->retval
  \end{minted}

  Matched patterns must have a \textcolor{Red}{static offset}.

  \framebreak

  Such mechanics fail if the compiler decouples the computation of the
  access address from the load/store instruction, e.g.:

  \begin{columns}
    \column{0.35\textwidth}
    \begin{minted}[fontsize=\footnotesize]{c}
switch (ctx->level) {
case 10:
  g = !\textcolor{Red}{bar}!(ctx->sk->family);
  break;
case 20:
  g = !\textcolor{Red}{bar}!(ctx->optlen);
  break;
}
return g % 2;
    \end{minted}

    \column{0.05\textwidth}
    $\rightarrow$
    \column{0.45\textwidth}

    \begin{minted}[fontsize=\footnotesize]{c}
switch (ctx->level) {
case 10:
  p = (void *)ctx->sk + 4;
  break;
case 20:
  p = ctx + 32;
  break;
}
g = !\textcolor{Red}{bar}!(*p);
return g % 2;
    \end{minted}
  \end{columns}

  \framebreak

  Verifier rejects programs after such transformation:

  \begin{minted}[fontsize=\fontsize{7}{8},frame=lines,framesep=5mm,highlightlines={7,8}]{c}
; switch (ctx->level) {
0: (61) r2 = *(u32 *)(r1 +24)         ; R1=ctx() R2=scalar(...)
1: (16) if w2 == 0x14 goto pc+5       ; R2=scalar(...)
2: (b4) w0 = 0                        ; R0=0
3: (56) if w2 != 0xa goto pc+7        ; R2=10
; g = bar(ctx->sk->family);
4: (79) r1 = *(u64 *)(r1 +0)          ; R1=sock()
5: (07) r1 += 4
R1 pointer arithmetic on sock prohibited
  \end{minted}

  \framebreak

  The workaround is to use a special attribute to make the BPF backend
  apply the following transformation before optimizer passes:

  \begin{minted}[fontsize=\footnotesize]{c}
  struct bpf_sockopt { ... } __attribute__((preserve_static_offset));
  ...
  switch (!\textcolor{Red}{@llvm.bpf.getelementptr.and.load.i32}!(ctx, 24)) {
  case 10:
    g = bar(ctx->sk->family); // offsets of 0 are not tinkered with
    break;
  case 20:
    g = bar(!\textcolor{Red}{@llvm.bpf.getelementptr.and.load.i32}!(ctx, 32));
    break;
  }
  \end{minted}

  \code{llvm.bpf.getelementptr.and.load} calls are replaced by actual
  \code{getelementptr} and \code{load} pairs right before IR
  translation to machine code.

\end{frame}

\begin{frame}
\frametitle{User visible workarounds}

The set of transformations applied by the LLVM backend is far from
being a complete remedy. This is evident from the kernel BPF selftests
themselves:

\begin{itemize}
\item \code{volatile} is used 302 times in 918 files.
\item \code{asm volatile("" : "+r"(var))} is used 26 times.
\end{itemize}

The issues are mostly similar to those already described. \\
(No detailed case study is available).

\end{frame}

\begin{frame}
\frametitle{Conclusion}
\begin{itemize}
\item So far, the LLVM BPF backend strategy has been reactive, with
  targeted counter-transformations added whenever new patterns are
  identified.
\item What is the strategy of the GCC BPF backend?
\item Do we want to agree on a \code{-Overifyable} compilation mode,
  as suggested some time ago by Jose Marchesi? \\
  If so, how should it be implemented:
  \begin{itemize}
  \item By targeted IR alternations, as LLVM does?
  \item Through backend-specific checks inside the optimizations themselves?\\
    (An approach rejected by LLVM upstream).

    % By backend specific checks in optimizations themselves \\ (an
    % option rejected by LLVM upstream)?
  \item Given the large number of user-visible workarounds, even an
    optimization pipeline completely separate from existing \code{-O2}
    might be worth considering.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Addendum: LLVM source code references}

  The described transformations are implemented by:
  \begin{itemize}
  \item \code{BPFAdjustOptImpl::avoidSpeculation()}
  \item \code{BPFAdjustOptImpl::serializeICMPCrossBB()}
  \item \code{BPFAdjustOptImpl::serializeICMPInBB()}
  \item \code{BPFPreserveStaticOffsetPass}
  \end{itemize}
\end{frame}

\end{document}
